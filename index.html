<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BB84 Quest ‚Äî Learn Quantum Key Distribution</title>
  <style>
    :root{
      /* Light minimalist palette */
      --bg: #f6f7fb;
      --card: #ffffff;
      --mutedcard:#fbfbfe;
      --text:#111827;      /* slate-900 */
      --muted:#6b7280;     /* gray-500 */
      --line:#e5e7eb;      /* gray-200 */
      --line2:#eef2f7;     /* very light */
      --shadow: 0 10px 22px rgba(17,24,39,.08);

      --accent:#10b981;    /* emerald-500 */
      --accent2:#2563eb;   /* blue-600 */
      --warn:#f59e0b;      /* amber-500 */
      --danger:#ef4444;    /* red-500 */

      --round: 18px;
      --round2: 14px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: radial-gradient(900px 450px at 15% 0%, rgba(37,99,235,.10), transparent 60%),
                  radial-gradient(900px 450px at 85% 0%, rgba(16,185,129,.10), transparent 60%),
                  var(--bg);
      color: var(--text);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
    }

    .app{
      width:min(1400px, 100%);
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .app{grid-template-columns:1fr}
    }

    .card{
      background: var(--card);
      border:1px solid var(--line);
      border-radius: var(--round);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    header{
      padding:16px 18px;
      background: linear-gradient(180deg, rgba(37,99,235,.06), transparent 70%);
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
    }
    header h1{ margin:0; font-size:18px; letter-spacing:.2px; }
    header p{
      margin:6px 0 0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
      max-width:70ch;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      background: rgba(16,185,129,.10);
      border:1px solid rgba(16,185,129,.25);
      color: #065f46;
      font-size:12px;
      white-space:nowrap;
      height: fit-content;
    }
    .pill b{ color: var(--text); }
    .content{ padding:12px; }

    /* ‚úÖ Minimal link styling */
    a{
      color: var(--accent2);
      text-decoration: none;
      border-bottom: 1px solid rgba(37,99,235,.25);
    }
    a:hover{
      border-bottom-color: rgba(37,99,235,.55);
    }

    .board{
      background: var(--mutedcard);
      border-radius: var(--round2);
      border:1px solid var(--line);
      padding:12px;
      min-height:380px;
    }
    .lanes{
      display:grid;
      grid-template-columns: 1fr 1.35fr 1fr;
      gap:12px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .lanes{grid-template-columns:1fr; }
    }

    .lane{
      background: #fff;
      border:1px solid var(--line);
      border-radius: var(--round2);
      padding:12px;
      min-height:310px;
    }
    .lane h2{
      margin:0 0 8px;
      font-size:14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .tag{
      font-size:11px;
      color:var(--muted);
      padding:5px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      background: #fff;
    }

    .character{
      display:flex;
      gap:10px;
      align-items:center;
      margin-top:8px;
      padding:10px;
      border-radius: 14px;
      background: #fff;
      border:1px solid var(--line);
    }
    .avatar{
      width:40px;
      height:40px;
      border-radius: 12px;
      display:grid;
      place-items:center;
      font-size:20px;
      background: rgba(16,185,129,.10);
      border:1px solid rgba(16,185,129,.25);
      flex:0 0 auto;
    }
    .avatar.bob{
      background: rgba(37,99,235,.10);
      border:1px solid rgba(37,99,235,.25);
    }
    .character .meta{display:flex; flex-direction:column; gap:2px;}
    .character .meta b{font-size:13px;}
    .character .meta span{font-size:12px; color:var(--muted);}

    .controls{ margin-top:10px; display:grid; gap:10px; }

    .row{
      display:grid;
      grid-auto-flow: column;
      grid-auto-columns: 1fr;
      gap:10px;
      align-items:stretch;
      margin-top:2px;
    }

    button{
      cursor:pointer;
      border:none;
      border-radius: 12px;
      padding:10px 12px;
      min-height: 42px;
      font-weight:650;
      font-size:13px;
      color: var(--text);
      background: #fff;
      border:1px solid var(--line);
      transition: transform .05s ease, box-shadow .18s ease, background .18s ease;
      user-select:none;
      width:100%;
    }
    button:hover{ box-shadow: 0 6px 14px rgba(17,24,39,.08); }
    button:active{ transform: translateY(1px); box-shadow:none; }

    button.primary{
      border-color: rgba(16,185,129,.35);
      background: rgba(16,185,129,.10);
    }
    button.blue{
      border-color: rgba(37,99,235,.35);
      background: rgba(37,99,235,.08);
    }
    button.warn{
      border-color: rgba(245,158,11,.40);
      background: rgba(245,158,11,.10);
    }
    button.danger{
      border-color: rgba(239,68,68,.35);
      background: rgba(239,68,68,.10);
    }
    button:disabled{
      opacity:.45;
      cursor:not-allowed;
      box-shadow:none;
      transform:none;
    }

    .bigChoice{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .choice{
      padding:12px;
      border-radius: 14px;
      border:1px solid var(--line);
      background: #fff;
      display:grid;
      gap:6px;
      text-align:left;
    }
    .choice b{font-size:14px}
    .choice span{font-size:12px; color:var(--muted); line-height:1.35}
    .choice .icon{font-size:18px; opacity:.9}
    .choice.selected{
      outline: 2px solid rgba(16,185,129,.55);
      background: rgba(16,185,129,.07);
      border-color: rgba(16,185,129,.25);
    }

    /* CHANNEL */
    .channel{ height:100%; display:flex; flex-direction:column; gap:10px; }
    .labels{ display:flex; justify-content:space-between; font-size:12px; color:var(--muted); }

    .bubbleSlot{
      min-height: 86px;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }
    .bubble{
      width:min(640px, 100%);
      padding:10px 12px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(37,99,235,.12), rgba(255,255,255,.98));
      border:1px solid rgba(37,99,235,.28);
      box-shadow: 0 12px 28px rgba(17,24,39,.14);
      display:grid;
      gap:6px;

      opacity:0;
      transform: translateY(-4px) scale(.99);
      transition: opacity .18s ease, transform .18s ease;
    }
    .bubble.show{
      opacity:1;
      transform: translateY(0) scale(1);
    }
    .bubble .title{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:750; font-size:13px;
    }
    .bubble .text{
      font-size:12px;
      color: #374151;
      line-height:1.45;
    }

    .pipe{
      position:relative;
      flex:1;
      border-radius: 14px;
      border:1px dashed #d7dce4;
      background: linear-gradient(180deg, rgba(37,99,235,.05), rgba(16,185,129,.04));
      overflow:hidden;
      min-height:240px;
    }
    .pipe:before{
      content:"";
      position:absolute;
      inset:0;
      background: repeating-linear-gradient(
        90deg,
        rgba(17,24,39,.03) 0px,
        rgba(17,24,39,.03) 10px,
        transparent 10px,
        transparent 24px
      );
      opacity:.55;
      pointer-events:none;
    }

    .photon{
      position:absolute;
      top:60%;
      left:12%;
      transform: translate(-50%, -50%);
      width:44px;
      height:44px;
      border-radius: 14px;
      display:grid;
      place-items:center;
      font-size:18px;
      background: rgba(16,185,129,.20);
      border:1px solid rgba(16,185,129,.35);
      opacity:0;
      z-index: 2;
    }
    .photon.blue{
      background: rgba(37,99,235,.15);
      border:1px solid rgba(37,99,235,.35);
    }
    .photon.show{ opacity:1; transition: opacity .22s ease; }

    @keyframes fly {
      0%   { left: 12%; transform: translate(-50%,-50%) scale(1); }
      100% { left: 88%; transform: translate(-50%,-50%) scale(1.02); }
    }
    .photon.fly{ animation: fly 1.25s ease-in-out forwards; }

    .eveGameLayer{
      position:absolute;
      inset:0;
      display:none;
      z-index: 5;
      pointer-events:none;
    }
    .eveGameLayer.show{ display:block; }
    .goalGate{
      position:absolute;
      top:0;
      right:0;
      width:12px;
      height:100%;
      background: linear-gradient(180deg, rgba(16,185,129,.22), rgba(16,185,129,.14));
      border-left:1px dashed rgba(16,185,129,.55);
    }
    .eveSprite,
    .messageSprite{
      position:absolute;
      width:40px;
      height:40px;
      border-radius:12px;
      display:grid;
      place-items:center;
      transform: translate(-50%, -50%);
      font-size:20px;
      box-shadow: 0 10px 20px rgba(17,24,39,.15);
    }
    .eveSprite{
      background: rgba(239,68,68,.17);
      border:1px solid rgba(239,68,68,.48);
    }
    .eveSprite.measure{
      animation: eveMeasurePulse .65s ease-in-out 2;
    }
    .messageSprite{
      background: rgba(16,185,129,.22);
      border:1px solid rgba(16,185,129,.45);
    }
    .evePhotonSprite{
      position:absolute;
      width:34px;
      height:34px;
      border-radius:11px;
      display:grid;
      place-items:center;
      transform: translate(-50%, -50%);
      font-size:17px;
      background: rgba(37,99,235,.18);
      border:1px solid rgba(37,99,235,.45);
      box-shadow: 0 10px 20px rgba(17,24,39,.16);
      opacity:0;
      transition: left 1.45s ease, opacity .24s ease;
    }
    .evePhotonSprite.show{ opacity:1; }
    .eveHud{
      position:absolute;
      left:10px;
      bottom:10px;
      font-size:11px;
      line-height:1.35;
      color:#374151;
      background: rgba(255,255,255,.9);
      border:1px solid var(--line);
      border-radius:10px;
      padding:7px 9px;
      max-width: 260px;
    }

    /* Side */
    .side{ display:grid; gap:14px; }
    .panel{ padding:14px; }
    .panel h3{ margin:0 0 8px; font-size:14px; }

    .status{ display:grid; gap:10px; }
    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .stat{
      background: #fff;
      border:1px solid var(--line);
      border-radius: 14px;
      padding:10px;
      display:grid;
      gap:4px;
    }
    .stat span{font-size:11px; color:var(--muted)}
    .stat b{font-size:14px}

    .keyline{ display:flex; flex-wrap:wrap; gap:6px; margin-top:4px; }
    .bit{
      width:26px;
      height:26px;
      border-radius: 10px;
      display:grid;
      place-items:center;
      font-weight:800;
      font-size:13px;
      border:1px solid var(--line);
      background: #fff;
      color: var(--text);
    }
    .bit.keep{
      border-color: rgba(16,185,129,.35);
      background: rgba(16,185,129,.12);
      color: #065f46;
    }
    .bit.bad{
      border-color: rgba(239,68,68,.45);
      background: rgba(239,68,68,.13);
      color:#991b1b;
    }

    .footerHint{
      color: var(--muted);
      font-size:12px;
      padding:0 2px;
      line-height:1.45;
    }

    @keyframes twinkle {
      0%{opacity:.0; transform: translateY(4px) scale(.95);}
      45%{opacity:1; transform: translateY(0) scale(1);}
      100%{opacity:0; transform: translateY(-6px) scale(.98);}
    }
    .sparkle{
      position:absolute;
      pointer-events:none;
      font-size:14px;
      animation: twinkle .7s ease-out forwards;
      opacity:0;
      z-index: 4;
    }
    @keyframes eveMeasurePulse {
      0%{ transform: translate(-50%, -50%) scale(1); }
      50%{ transform: translate(-50%, -50%) scale(1.16); }
      100%{ transform: translate(-50%, -50%) scale(1); }
    }

    /* =========================
       ‚úÖ Tutorial popups (tour)
       ========================= */
    .tourOverlay{
      position:fixed;
      inset:0;
      background: rgba(17,24,39,.35);
      display:none;
      z-index: 9999;
    }
    .tourOverlay.show{ display:block; }

    .welcomeOverlay{
      position:fixed;
      inset:0;
      background: rgba(17,24,39,.55);
      display:none;
      z-index: 11000;
    }
    .welcomeOverlay.show{
      display:grid;
      place-items:center;
      padding:16px;
    }
    .welcomeModal{
      width:min(860px, 100%);
      max-height: min(85vh, 860px);
      overflow:auto;
      background: #fff;
      border:1px solid var(--line);
      border-radius: 16px;
      box-shadow: 0 24px 60px rgba(17,24,39,.28);
      padding:16px;
      display:grid;
      gap:12px;
    }
    .welcomeModal h2{
      margin:0;
      font-size:18px;
      letter-spacing:.2px;
    }
    .welcomeBody{
      color:#374151;
      font-size:13px;
      line-height:1.6;
      display:grid;
      gap:10px;
    }
    .welcomeBody p{
      margin:0;
    }
    .welcomeActions{
      display:flex;
      justify-content:flex-end;
      align-items:center;
      gap:8px;
      padding-top:2px;
    }
    .welcomeActions button{
      width:auto;
      min-height: 38px;
      padding:8px 12px;
      border-radius:10px;
      font-size:12px;
      font-weight:700;
    }

    .resultOverlay{
      position:fixed;
      inset:0;
      background: rgba(17,24,39,.56);
      display:none;
      z-index: 12000;
    }
    .resultOverlay.show{
      display:grid;
      place-items:center;
      padding:16px;
    }
    .resultModal{
      position:relative;
      width:min(680px, 100%);
      background:#fff;
      border:1px solid var(--line);
      border-radius:16px;
      box-shadow: 0 24px 60px rgba(17,24,39,.28);
      padding:16px;
      overflow:hidden;
      animation: resultPopIn .28s ease-out;
    }
    .resultModal.win{ border-color: rgba(16,185,129,.45); }
    .resultModal.lose{ border-color: rgba(239,68,68,.45); }
    .resultTitle{
      display:flex;
      align-items:center;
      gap:8px;
      margin:0 0 8px;
      font-size:18px;
      letter-spacing:.2px;
    }
    .resultIcon{
      width:32px;
      height:32px;
      border-radius:10px;
      display:grid;
      place-items:center;
      font-size:20px;
      background: rgba(17,24,39,.06);
      border:1px solid var(--line);
      flex:0 0 auto;
    }
    .resultModal.win .resultIcon{ animation: resultWinBob 1s ease-in-out infinite; }
    .resultModal.lose .resultIcon{ animation: resultLoseShake .5s ease-in-out infinite; }
    .resultBody{
      font-size:13px;
      color:#374151;
      line-height:1.55;
      display:grid;
      gap:8px;
      margin-bottom:10px;
      position:relative;
      z-index:2;
    }
    .resultBody p{ margin:0; }
    .resultActions{
      display:flex;
      justify-content:flex-end;
      gap:8px;
      position:relative;
      z-index:2;
    }
    .resultActions button{
      width:auto;
      min-height:38px;
      padding:8px 12px;
      border-radius:10px;
      font-size:12px;
      font-weight:700;
    }
    .resultBurst{
      position:absolute;
      inset:0;
      overflow:hidden;
      pointer-events:none;
      z-index:1;
    }
    .resultParticle{
      position:absolute;
      font-size:16px;
      opacity:0;
      left:var(--x);
      bottom:-12px;
      animation: resultRise var(--dur, 1.6s) ease-out var(--delay, 0s) forwards;
    }
    .resultParticle.lose{
      top:-10px;
      bottom:auto;
      animation: resultDrop var(--dur, 1.4s) ease-in var(--delay, 0s) forwards;
    }
    @keyframes resultPopIn{
      0%{ opacity:0; transform: translateY(10px) scale(.97); }
      100%{ opacity:1; transform: translateY(0) scale(1); }
    }
    @keyframes resultRise{
      0%{ opacity:0; transform: translateY(0) scale(.75) rotate(0deg); }
      20%{ opacity:1; }
      100%{ opacity:0; transform: translateY(-170px) scale(1.05) rotate(16deg); }
    }
    @keyframes resultDrop{
      0%{ opacity:0; transform: translateY(0) rotate(0deg); }
      20%{ opacity:1; }
      100%{ opacity:0; transform: translateY(180px) rotate(-22deg); }
    }
    @keyframes resultWinBob{
      0%{ transform: translateY(0) rotate(0deg); }
      50%{ transform: translateY(-2px) rotate(7deg); }
      100%{ transform: translateY(0) rotate(0deg); }
    }
    @keyframes resultLoseShake{
      0%{ transform: translateX(0); }
      25%{ transform: translateX(-1px); }
      50%{ transform: translateX(1px); }
      75%{ transform: translateX(-1px); }
      100%{ transform: translateX(0); }
    }

    .tourTooltip{
      position:fixed;
      width: min(420px, calc(100vw - 24px));
      background: #fff;
      border:1px solid var(--line);
      border-radius: 14px;
      box-shadow: 0 18px 45px rgba(17,24,39,.20);
      padding:12px;
      z-index: 10000;
      display:none;
    }
    .tourTooltip.show{ display:block; }

    .tourTitle{
      font-weight:800;
      font-size:13px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:6px;
    }
    .tourBody{
      color: var(--muted);
      font-size:12px;
      line-height:1.45;
      margin-bottom:10px;
    }
    .tourActions{
      display:flex;
      gap:8px;
      justify-content:flex-end;
      align-items:center;
    }
    .tourActions button{
      width:auto;
      min-height: 36px;
      padding:8px 10px;
      border-radius: 10px;
      font-size:12px;
      font-weight:700;
    }
    .tourCounter{
      font-size:11px;
      color: var(--muted);
      border:1px solid var(--line);
      border-radius:999px;
      padding:4px 8px;
      background:#fff;
      white-space:nowrap;
    }

    .tourHighlight{
      position:relative;
      z-index: 10001; /* above overlay */
      outline: 3px solid rgba(37,99,235,.35);
      border-radius: 14px;
      box-shadow: 0 0 0 8px rgba(37,99,235,.10);
      transition: outline-color .18s ease, box-shadow .18s ease;
    }

    @media (max-width: 980px){
      .tourHighlight{ border-radius: 14px; }
    }
  </style>
</head>

<body>
  <div class="app">
    <section class="card">
      <header>
        <div>
          <h1>BB84 Quest üß™üîë</h1>
          <p>
            You are <b>Alice</b>. Pick a secret bit (0/1) and a ‚Äúmagic lens‚Äù (basis ‚ûï or ‚úñ).
            Send a photon to <b>Bob</b>, who measures with a random lens.
            If your lenses match, you keep that bit for your shared secret key!
          </p>
        </div>
        <div class="pill"><span>Goal:</span> <b>Build a key</b></div>
      </header>

      <div class="content">
        <div class="board">
          <div class="lanes">
            <!-- ALICE -->
            <div class="lane" id="laneAlice">
              <h2>Alice (You) üê∞</h2>

              <div class="character">
                <div class="avatar">üê∞</div>
                <div class="meta">
                  <b>Pick a bit + basis</b>
                  <span>Bit is 0 or 1. Basis is ‚ûï or ‚úñ.</span>
                </div>
              </div>

              <div class="controls">
                <div class="bigChoice" id="bitChoices">
                  <div class="choice" data-bit="0" tabindex="0" id="bit0">
                    <div class="icon">0Ô∏è‚É£</div><b>Bit = 0</b>
                  </div>
                  <div class="choice" data-bit="1" tabindex="0" id="bit1">
                    <div class="icon">1Ô∏è‚É£</div><b>Bit = 1</b>
                  </div>
                </div>

                <div class="bigChoice" id="basisChoices">
                  <div class="choice" data-basis="PLUS" tabindex="0" id="basisPlus">
                    <div class="icon">‚ûï</div><b>Basis = ‚ûï</b>
                  </div>
                  <div class="choice" data-basis="CROSS" tabindex="0" id="basisCross">
                    <div class="icon">‚úñ</div><b>Basis = ‚úñ</b>
                  </div>
                </div>

                <div class="row">
                  <button class="primary" id="btnEncode" disabled>Encode Photon ‚ú®</button>
                  <button class="warn" id="btnResetRound">Reset Round ‚Ü©Ô∏è</button>
                </div>

                <button class="primary" id="btnSend" disabled>Send Through Channel üöÄ</button>
              </div>
            </div>

            <!-- CHANNEL -->
            <div class="lane">
              <h2>Quantum Channel üåå</h2>

              <div class="channel">
                <div class="labels"><span>from Alice</span><span>to Bob</span></div>

                <div class="bubbleSlot">
                  <div class="bubble" id="bubble">
                    <div class="title">
                      <span id="bubbleTitle">Ready!</span>
                      <span class="tag">BB84</span>
                    </div>
                    <div class="text" id="bubbleText">Pick a bit and a basis, then encode and send.</div>
                  </div>
                </div>

                <div class="pipe" id="pipe">
                  <div class="photon" id="photon" aria-label="photon">‚öõÔ∏è</div>
                  <div class="eveGameLayer" id="eveGameLayer" aria-hidden="true">
                    <div class="goalGate" aria-hidden="true"></div>
                    <div class="eveSprite" id="eveSprite" aria-label="Eve">üïµÔ∏è</div>
                    <div class="messageSprite" id="messageSprite" aria-label="Message">üíå</div>
                    <div class="evePhotonSprite" id="evePhotonSprite" aria-label="Eve Photon">‚öõÔ∏è</div>
                    <div class="eveHud" id="eveHud">Use Arrow keys or WASD. Reach Bob's side without being intercepted by Eve.</div>
                  </div>
                </div>
              </div>
            </div>

            <!-- BOB -->
            <div class="lane" id="laneBob">
              <h2>Bob ü§ñ</h2>

              <div class="character">
                <div class="avatar bob">ü§ñ</div>
                <div class="meta">
                  <b>Bob measures randomly</b>
                  <span>He picks ‚ûï or ‚úñ and measures.</span>
                </div>
              </div>

              <div class="controls">
                <div class="stat"><span>Bob's chosen basis</span><b id="bobBasis">‚Äî</b></div>
                <div class="stat"><span>Bob's measured bit</span><b id="bobBit">‚Äî</b></div>
                <button class="blue" id="btnMeasure" disabled>Bob Measures üéõÔ∏è</button>
                <div class="row">
                  <button class="blue" id="btnRevealBases" disabled>Reveal Bases üó£Ô∏è</button>
                  <button class="blue" id="btnNextRound" disabled>Next Photon ‚û°Ô∏è</button>
                </div>
              </div>

            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- SIDE -->
    <aside class="side">
      <section class="card panel">
        <h3>Scoreboard</h3>
        <div class="status">
          <div class="grid2">
            <div class="stat"><span>Photons sent</span><b id="sentCount">0</b></div>
            <div class="stat"><span>Kept (matching bases)</span><b id="keptCount">0</b></div>
          </div>

          <div class="stat">
            <span>Alice sifted key</span>
            <div class="keyline" id="aliceKeyBits"></div>
          </div>

          <div class="stat">
            <span>Bob sifted key</span>
            <div class="keyline" id="bobKeyBits"></div>
          </div>

          <div class="footerHint">Keep bits only when bases match (‚ûï‚ûï or ‚úñ‚úñ).</div>
        </div>
      </section>

      <section class="card panel">
        <h3>Big Idea</h3>
        <div class="footerHint">
          Alice encodes using a secret basis. Bob measures with a random basis.
          Later they compare bases (not bits). Matching bases become shared secret bits.
        </div>
        <div style="margin-top:10px; display:grid; gap:10px;">
          <button class="primary" id="btnFinalizeGame">Finalize Game üß™</button>
          <button class="warn" id="btnEveMode">Eve Attack: OFF</button>
          <button class="danger" id="btnResetAll">Reset Everything</button>
        </div>
      </section>

      <!-- Authors section -->
      <section class="card panel">
        <h3>Authors</h3>
        <div class="footerHint">
          Made by <b>Lidjia Petrovic</b>, <b>Mar L√≥pez</b> and <b>Javier Fern√°ndez</b> for the
          <b>Quantum Communications and Cryptography</b> course of the <b>University of Barcelona</b>.
          <br><br>
          GitHub: <a href="https://github.com/jjavierf64/bb84-website" target="_blank" rel="noopener noreferrer">github.com/jjavierf64/bb84-website</a>
        </div>
      </section>
    </aside>
  </div>

  <div class="resultOverlay" id="resultOverlay">
    <div class="resultModal" id="resultModal" role="dialog" aria-modal="true" aria-label="Game Result">
      <div class="resultBurst" id="resultBurst" aria-hidden="true"></div>
      <h2 class="resultTitle"><span class="resultIcon" id="resultIcon">üèÅ</span><span id="resultTitle">Game Result</span></h2>
      <div class="resultBody" id="resultBody"></div>
      <div class="resultActions">
        <button class="blue" id="resultCloseBtn" type="button">Continue</button>
        <button class="primary" id="resultResetBtn" type="button">Play Again</button>
      </div>
    </div>
  </div>

  <div class="welcomeOverlay" id="welcomeOverlay">
    <div class="welcomeModal" role="dialog" aria-modal="true" aria-label="Welcome to BB84 Quest">
      <h2>Welcome to BB84 Quest</h2>
      <div class="welcomeBody">
        <p>In quantum communication, Alice and Bob need to share a secret key to encrypt messages (using a one-time pad). The challenge is creating that key securely over a channel that might be watched.</p>

        <p>One famous way to do this is the BB84 protocol. Alice randomly chooses a basis (‚ûï or √ó) and a bit (0 or 1), encodes it into a qubit, and sends it to Bob.</p>

        <p>Bob also randomly chooses a basis and measures the qubit. Later, Alice and Bob publicly compare only which bases they used. If the bases match, they keep the bit; if not, they discard it. The kept bits form the secret key.</p>

        <p>If an eavesdropper (Eve) tries to intercept, she must guess a basis. Guessing wrong disturbs the qubit, creating errors. That means Alice and Bob can detect her.</p>

        <p>At the end, they compare a small random sample of their kept bits. Too many mismatches means someone interfered, so they throw the key away and restart.</p>

        <p>You are Alice. Choose a basis and a bit, send photons to Bob, and see if you can build a secure key‚Äîor detect an attack.</p>

      </div>
      <div class="welcomeActions">
        <button class="primary" id="welcomeStartBtn" type="button">Start Experiment</button>
      </div>
    </div>
  </div>

  <!-- ‚úÖ Tutorial UI -->
  <div class="tourOverlay" id="tourOverlay"></div>
  <div class="tourTooltip" id="tourTooltip" role="dialog" aria-modal="true" aria-label="Tutorial">
    <div class="tourTitle">
      <span id="tourTitle"></span>
      <span class="tourCounter" id="tourCounter"></span>
    </div>
    <div class="tourBody" id="tourBody"></div>
    <div class="tourActions">
      <button class="warn" id="tourSkipBtn" type="button">Skip</button>
      <button class="blue" id="tourNextBtn" type="button">Next</button>
    </div>
  </div>

  <script>
    const state = {
      phase: "PICK",
      aliceBit: null,
      aliceBasis: null,
      bobBasis: null,
      bobBit: null,
      eveIntercepted: false,
      eveMeasureBasis: null,
      eveMeasuredBit: null,
      eveResendBasis: null,
      sent: 0,
      kept: 0,
      aliceKey: [],
      bobKey: []
    };

    const bitChoices = document.getElementById("bitChoices");
    const basisChoices = document.getElementById("basisChoices");
    const btnEncode = document.getElementById("btnEncode");
    const btnSend = document.getElementById("btnSend");
    const btnMeasure = document.getElementById("btnMeasure");
    const btnRevealBases = document.getElementById("btnRevealBases");
    const btnNextRound = document.getElementById("btnNextRound");
    const btnResetRound = document.getElementById("btnResetRound");
    const btnFinalizeGame = document.getElementById("btnFinalizeGame");
    const btnEveMode = document.getElementById("btnEveMode");
    const btnResetAll = document.getElementById("btnResetAll");

    const laneAlice = document.getElementById("laneAlice");
    const laneBob = document.getElementById("laneBob");

    const photon = document.getElementById("photon");
    const pipe = document.getElementById("pipe");
    const eveGameLayer = document.getElementById("eveGameLayer");
    const eveSprite = document.getElementById("eveSprite");
    const messageSprite = document.getElementById("messageSprite");
    const evePhotonSprite = document.getElementById("evePhotonSprite");
    const eveHud = document.getElementById("eveHud");

    const bubble = document.getElementById("bubble");
    const bubbleTitle = document.getElementById("bubbleTitle");
    const bubbleText = document.getElementById("bubbleText");

    const bobBasisEl = document.getElementById("bobBasis");
    const bobBitEl = document.getElementById("bobBit");

    const sentCount = document.getElementById("sentCount");
    const keptCount = document.getElementById("keptCount");
    const aliceKeyBits = document.getElementById("aliceKeyBits");
    const bobKeyBits = document.getElementById("bobKeyBits");
    const resultOverlay = document.getElementById("resultOverlay");
    const resultModal = document.getElementById("resultModal");
    const resultBurst = document.getElementById("resultBurst");
    const resultIcon = document.getElementById("resultIcon");
    const resultTitle = document.getElementById("resultTitle");
    const resultBody = document.getElementById("resultBody");
    const resultCloseBtn = document.getElementById("resultCloseBtn");
    const resultResetBtn = document.getElementById("resultResetBtn");

    const randBit = () => (Math.random() < 0.5 ? 0 : 1);
    const randBasis = () => (Math.random() < 0.5 ? "PLUS" : "CROSS");
    const basisIcon = (b) => (b === "PLUS" ? "‚ûï" : b === "CROSS" ? "‚úñ" : "‚Äî");
    const clamp = (v, min, max) => Math.max(min, Math.min(v, max));

    const eveMode = {
      enabled: false,
      active: false,
      postAttackAnimating: false,
      raf: 0,
      resolve: null,
      lastTs: 0,
      keys: new Set(),
      message: { x: 0, y: 0, r: 20, speed: 260 },
      eve: { x: 0, y: 0, r: 20, vx: 180, vy: 150 }
    };

    function setBubble(title, text){
      bubbleTitle.textContent = title;
      bubbleText.textContent = text;
      bubble.classList.add("show");
    }

    function spawnResultParticles(win){
      resultBurst.innerHTML = "";
      const icons = win ? ["‚ú®", "üîê", "‚úÖ", "üéâ"] : ["‚ö†Ô∏è", "‚ùå", "üí•", "üïµÔ∏è"];
      const count = win ? 24 : 20;
      for (let i = 0; i < count; i += 1){
        const p = document.createElement("span");
        p.className = `resultParticle ${win ? "win" : "lose"}`;
        p.textContent = icons[Math.floor(Math.random() * icons.length)];
        p.style.setProperty("--x", `${8 + Math.random() * 84}%`);
        p.style.setProperty("--delay", `${Math.random() * 0.8}s`);
        p.style.setProperty("--dur", `${1.2 + Math.random() * 0.9}s`);
        resultBurst.appendChild(p);
      }
    }

    function hideResultOverlay(){
      resultOverlay.classList.remove("show");
      resultModal.classList.remove("win");
      resultModal.classList.remove("lose");
      resultBurst.innerHTML = "";
    }

    function showResultOverlay(win){
      resultModal.classList.remove("win");
      resultModal.classList.remove("lose");
      resultModal.classList.add(win ? "win" : "lose");
      resultIcon.textContent = win ? "üèÜ" : "üö®";
      resultTitle.textContent = win ? "Keys Match ‚Äî You Win!" : "Keys Mismatch ‚Äî You Lose";
      if (win){
        resultBody.innerHTML = `
          <p>Congratulations! You now share a key with Bob.</p>
          <p>For this game, we compare the full raw key and both keys match, so your communication is secure.</p>
        `;
      } else {
        resultBody.innerHTML = `
          <p>Congratulations! You now share a key with Bob. But is the key really secret? We compared Bob's key and found errors.</p>
          <p>This suggests Eve may have attacked the process. The key must be discarded, so you lose this round.</p>
          <p>In real BB84, Alice and Bob compare only a random sample (about 10-20%) to estimate error rate; in this game we compare the full raw key.</p>
        `;
      }
      spawnResultParticles(win);
      resultOverlay.classList.add("show");
    }

    function sparkle(x, y, char="‚ú®"){
      const s = document.createElement("div");
      s.className = "sparkle";
      s.textContent = char;
      s.style.left = `${x}px`;
      s.style.top = `${y}px`;
      pipe.appendChild(s);
      setTimeout(() => s.remove(), 800);
    }

    function positionSprite(el, x, y){
      el.style.left = `${x}px`;
      el.style.top = `${y}px`;
    }

    function resetEveChallenge(){
      const r = pipe.getBoundingClientRect();
      const w = Math.max(220, r.width);
      const h = Math.max(180, r.height);

      eveMode.message.x = 28;
      eveMode.message.y = h * 0.5;
      eveMode.eve.x = w * 0.62;
      eveMode.eve.y = h * 0.5;
      eveMode.eve.vx = (Math.random() < 0.5 ? -1 : 1) * (170 + Math.random() * 50);
      eveMode.eve.vy = (Math.random() < 0.5 ? -1 : 1) * (130 + Math.random() * 50);

      positionSprite(messageSprite, eveMode.message.x, eveMode.message.y);
      positionSprite(eveSprite, eveMode.eve.x, eveMode.eve.y);
      evePhotonSprite.classList.remove("show");
    }

    function updateEveToggleButton(){
      btnEveMode.textContent = eveMode.enabled ? "Eve Attack: ON üïµÔ∏è" : "Eve Attack: OFF";
    }

    function hideEveLayer(){
      eveGameLayer.classList.remove("show");
      eveGameLayer.setAttribute("aria-hidden", "true");
      eveHud.textContent = "Use Arrow keys or WASD. Reach Bob's side without being intercepted by Eve.";
      evePhotonSprite.classList.remove("show");
      eveSprite.classList.remove("measure");
    }

    function finishEveChallenge(intercepted = false, keepLayer = false){
      if (!eveMode.active) return;
      eveMode.active = false;
      eveMode.keys.clear();
      cancelAnimationFrame(eveMode.raf);
      if (!keepLayer){
        hideEveLayer();
      }
      window.removeEventListener("keydown", onEveKeyDown);
      window.removeEventListener("keyup", onEveKeyUp);
      if (eveMode.resolve){
        const resolver = eveMode.resolve;
        eveMode.resolve = null;
        resolver(intercepted);
      }
      updateUI();
    }

    function onEveKeyDown(e){
      if (!eveMode.active) return;
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "w", "a", "s", "d", "W", "A", "S", "D"].includes(e.key)){
        e.preventDefault();
        eveMode.keys.add(e.key.toLowerCase());
      }
    }

    function onEveKeyUp(e){
      if (!eveMode.active) return;
      eveMode.keys.delete(e.key.toLowerCase());
    }

    function winEveMode(){
      const r = pipe.getBoundingClientRect();
      sparkle(r.width * 0.9, r.height * 0.5, "‚úÖ");
      finishEveChallenge(false);
    }

    function loseEveMode(){
      const r = pipe.getBoundingClientRect();
      sparkle(r.width * 0.64, r.height * 0.5, "‚ö†Ô∏è");
      finishEveChallenge(true, true);
    }

    function runEveMode(ts){
      if (!eveMode.active) return;

      const r = pipe.getBoundingClientRect();
      const w = Math.max(220, r.width);
      const h = Math.max(180, r.height);
      const dt = Math.min(0.04, (ts - eveMode.lastTs) / 1000 || 0.016);
      eveMode.lastTs = ts;

      const left = eveMode.keys.has("arrowleft") || eveMode.keys.has("a");
      const right = eveMode.keys.has("arrowright") || eveMode.keys.has("d");
      const up = eveMode.keys.has("arrowup") || eveMode.keys.has("w");
      const down = eveMode.keys.has("arrowdown") || eveMode.keys.has("s");

      let dx = (right ? 1 : 0) - (left ? 1 : 0);
      let dy = (down ? 1 : 0) - (up ? 1 : 0);
      if (dx !== 0 && dy !== 0){
        dx *= 0.7071;
        dy *= 0.7071;
      }

      eveMode.message.x += dx * eveMode.message.speed * dt;
      eveMode.message.y += dy * eveMode.message.speed * dt;
      eveMode.message.x = clamp(eveMode.message.x, eveMode.message.r, w - eveMode.message.r);
      eveMode.message.y = clamp(eveMode.message.y, eveMode.message.r, h - eveMode.message.r);

      eveMode.eve.x += eveMode.eve.vx * dt;
      eveMode.eve.y += eveMode.eve.vy * dt;
      if (eveMode.eve.x <= eveMode.eve.r || eveMode.eve.x >= w - eveMode.eve.r){
        eveMode.eve.vx *= -1;
        eveMode.eve.x = clamp(eveMode.eve.x, eveMode.eve.r, w - eveMode.eve.r);
      }
      if (eveMode.eve.y <= eveMode.eve.r || eveMode.eve.y >= h - eveMode.eve.r){
        eveMode.eve.vy *= -1;
        eveMode.eve.y = clamp(eveMode.eve.y, eveMode.eve.r, h - eveMode.eve.r);
      }

      positionSprite(messageSprite, eveMode.message.x, eveMode.message.y);
      positionSprite(eveSprite, eveMode.eve.x, eveMode.eve.y);

      const dxHit = eveMode.message.x - eveMode.eve.x;
      const dyHit = eveMode.message.y - eveMode.eve.y;
      const hitDist = eveMode.message.r + eveMode.eve.r - 4;
      if ((dxHit * dxHit + dyHit * dyHit) <= (hitDist * hitDist)){
        loseEveMode();
        return;
      }

      if (eveMode.message.x >= w - eveMode.message.r - 8){
        winEveMode();
        return;
      }

      eveMode.raf = requestAnimationFrame(runEveMode);
    }

    function startEveChallenge(){
      if (eveMode.active) return;
      eveMode.active = true;
      eveGameLayer.classList.add("show");
      eveGameLayer.setAttribute("aria-hidden", "false");
      eveHud.textContent = "Eve attack in progress. Use Arrow keys or WASD and get the message to Bob.";
      photon.className = "photon";
      photon.style.opacity = "0";
      resetEveChallenge();
      updateUI();
      eveMode.lastTs = performance.now();
      window.addEventListener("keydown", onEveKeyDown);
      window.addEventListener("keyup", onEveKeyUp);
      eveMode.raf = requestAnimationFrame(runEveMode);
      return new Promise((resolve) => {
        eveMode.resolve = resolve;
      });
    }

    async function animateEveAttackSequence(measureBasis, resendBasis){
      const r = pipe.getBoundingClientRect();
      const y = clamp(eveMode.eve.y, 20, Math.max(20, r.height - 20));

      eveHud.textContent = `Eve measures in basis ${basisIcon(measureBasis)}...`;
      eveSprite.classList.add("measure");
      sparkle(eveMode.eve.x, y, "üìè");
      await wait(980);
      eveSprite.classList.remove("measure");

      eveHud.textContent = `Eve re-encodes in random basis ${basisIcon(resendBasis)}...`;
      sparkle(eveMode.eve.x, y, "üîê");
      await wait(820);

      evePhotonSprite.style.left = `${eveMode.eve.x}px`;
      evePhotonSprite.style.top = `${y}px`;
      evePhotonSprite.classList.add("show");

      await wait(140);
      eveHud.textContent = "Eve sends her photon to Bob.";
      sparkle(eveMode.eve.x, y, "üöÄ");
      evePhotonSprite.style.left = `${Math.max(eveMode.eve.x + 8, r.width - 22)}px`;

      await wait(1500);
      evePhotonSprite.classList.remove("show");
    }

    function updateUI(){
      const blockForEveMode = eveMode.active || eveMode.postAttackAnimating;
      const hasPick = state.aliceBit !== null && state.aliceBasis !== null;
      btnEncode.disabled = blockForEveMode || !(state.phase === "PICK" && hasPick);
      btnSend.disabled = blockForEveMode || !(state.phase === "ENCODED");
      btnMeasure.disabled = blockForEveMode || !(state.phase === "SENT");
      btnRevealBases.disabled = blockForEveMode || !(state.phase === "MEASURED");
      btnNextRound.disabled = blockForEveMode || !(state.phase === "REVEALED");
      btnResetRound.disabled = blockForEveMode;
      btnEveMode.disabled = blockForEveMode;
      btnResetAll.disabled = blockForEveMode;
      btnFinalizeGame.disabled = blockForEveMode;

      bobBasisEl.textContent = basisIcon(state.bobBasis);
      bobBitEl.textContent = (state.bobBit === null ? "‚Äî" : String(state.bobBit));

      sentCount.textContent = String(state.sent);
      keptCount.textContent = String(state.aliceKey.length);

      aliceKeyBits.innerHTML = "";
      bobKeyBits.innerHTML = "";
      const maxKeyLen = Math.max(state.aliceKey.length, state.bobKey.length);
      for (let i = 0; i < maxKeyLen; i += 1){
        const a = state.aliceKey[i];
        const b = state.bobKey[i];
        const aEl = document.createElement("div");
        aEl.className = "bit keep";
        aEl.textContent = (a ?? "‚Äî");
        aliceKeyBits.appendChild(aEl);

        const bEl = document.createElement("div");
        bEl.className = "bit keep";
        bEl.textContent = (b ?? "‚Äî");
        if (a !== undefined && b !== undefined && a !== b){
          bEl.classList.add("bad");
        }
        bobKeyBits.appendChild(bEl);
      }
      if (maxKeyLen === 0){
        const ghostA = document.createElement("div");
        ghostA.className = "bit";
        ghostA.style.opacity = ".6";
        ghostA.textContent = "‚Äî";
        aliceKeyBits.appendChild(ghostA);

        const ghostB = document.createElement("div");
        ghostB.className = "bit";
        ghostB.style.opacity = ".6";
        ghostB.textContent = "‚Äî";
        bobKeyBits.appendChild(ghostB);
      }

      // keep tutorial gating responsive
      tutorialUpdate();
    }

    function clearSelections(container){
      [...container.querySelectorAll(".choice")].forEach(c => c.classList.remove("selected"));
    }

    function resetRound(){
      state.phase = "PICK";
      state.aliceBit = null;
      state.aliceBasis = null;
      state.bobBasis = null;
      state.bobBit = null;
      state.eveIntercepted = false;
      state.eveMeasureBasis = null;
      state.eveMeasuredBit = null;
      state.eveResendBasis = null;

      clearSelections(bitChoices);
      clearSelections(basisChoices);

      photon.className = "photon";
      photon.style.left = "12%";
      photon.style.opacity = "0";
      hideEveLayer();
      eveMode.postAttackAnimating = false;

      updateUI();
    }

    function resetAll(){
      finishEveChallenge(false);
      hideEveLayer();
      hideResultOverlay();
      eveMode.postAttackAnimating = false;
      state.sent = 0;
      state.kept = 0;
      state.aliceKey = [];
      state.bobKey = [];
      resetRound();
      setBubble("Clean Slate", "Everything reset. Let's build a new key!");
    }

    function selectBit(bit){
      if (eveMode.active || eveMode.postAttackAnimating) return;
      state.aliceBit = bit;
      clearSelections(bitChoices);
      bitChoices.querySelector(`[data-bit="${bit}"]`).classList.add("selected");
      setBubble("Bit chosen", `Alice picked bit ${bit}. Now pick a basis (‚ûï or ‚úñ).`);
      updateUI();
    }

    function selectBasis(basis){
      if (eveMode.active || eveMode.postAttackAnimating) return;
      state.aliceBasis = basis;
      clearSelections(basisChoices);
      basisChoices.querySelector(`[data-basis="${basis}"]`).classList.add("selected");
      setBubble("Basis chosen", `Alice picked basis ${basisIcon(basis)}. Now encode!`);
      updateUI();
    }

    bitChoices.addEventListener("click", (e) => {
      const card = e.target.closest(".choice");
      if(!card) return;
      selectBit(Number(card.dataset.bit));
    });
    basisChoices.addEventListener("click", (e) => {
      const card = e.target.closest(".choice");
      if(!card) return;
      selectBasis(card.dataset.basis);
    });

    function handleEnterSelect(container, handler){
      container.addEventListener("keydown", (e) => {
        if(e.key !== "Enter") return;
        const card = e.target.closest(".choice");
        if(!card) return;
        handler(card);
      });
    }
    handleEnterSelect(bitChoices, (card) => selectBit(Number(card.dataset.bit)));
    handleEnterSelect(basisChoices, (card) => selectBasis(card.dataset.basis));

    btnEncode.addEventListener("click", () => {
      state.phase = "ENCODED";

      photon.className = "photon show " + (state.aliceBasis === "CROSS" ? "blue" : "");
      photon.textContent = (state.aliceBasis === "PLUS")
        ? (state.aliceBit === 0 ? "‚¨áÔ∏è" : "‚û°Ô∏è")
        : (state.aliceBit === 0 ? "‚ÜôÔ∏è" : "‚ÜóÔ∏è");

      setBubble("Encoded", "Photon now carries your bit using your secret basis.");
      updateUI();

      const r = pipe.getBoundingClientRect();
      sparkle(r.width * 0.18, r.height * 0.62, "‚ú®");
    });

    btnSend.addEventListener("click", async () => {
      state.phase = "SENT";
      state.sent += 1;

      state.eveIntercepted = false;
      state.eveMeasureBasis = null;
      state.eveMeasuredBit = null;
      state.eveResendBasis = null;

      if (eveMode.enabled){
        setBubble("Sending (Eve ON)", "Guide the message to Bob. If Eve touches it, she intercepts and attacks.");
      } else {
        setBubble("Sending", "Photon is traveling through the quantum channel‚Ä¶");
      }
      updateUI();

      if (eveMode.enabled){
        const intercepted = await startEveChallenge();
        state.eveIntercepted = intercepted;

        if (intercepted){
          state.eveMeasureBasis = randBasis();
          state.eveMeasuredBit = (state.eveMeasureBasis === state.aliceBasis) ? state.aliceBit : randBit();
          state.eveResendBasis = randBasis();
          eveMode.postAttackAnimating = true;
          updateUI();
          await animateEveAttackSequence(state.eveMeasureBasis, state.eveResendBasis);
          eveMode.postAttackAnimating = false;
          hideEveLayer();
          setBubble(
            "Eve intercepted!",
            `Eve measured in ${basisIcon(state.eveMeasureBasis)} and resent using random basis ${basisIcon(state.eveResendBasis)}.`
          );
        } else {
          hideEveLayer();
          setBubble("Arrived", "Photon reached Bob without interception. Now Bob measures with a random basis.");
        }

        updateUI();
        return;
      }

      photon.classList.add("fly");
      photon.style.opacity = "1";

      await wait(1300);

      photon.classList.remove("fly");
      photon.style.left = "88%";

      setBubble("Arrived", "Photon reached Bob. Now Bob measures with a random basis.");
      updateUI();
    });

    btnMeasure.addEventListener("click", () => {
      state.bobBasis = randBasis();
      let sourceBasis = state.aliceBasis;
      let sourceBit = state.aliceBit;
      let viaEve = false;
      if (eveMode.enabled && state.eveIntercepted){
        sourceBasis = state.eveResendBasis;
        sourceBit = state.eveMeasuredBit;
        viaEve = true;
      }
      const match = (state.bobBasis === sourceBasis);
      state.bobBit = match ? sourceBit : randBit();

      state.phase = "MEASURED";

      if (viaEve){
        setBubble(
          "Measured after Eve",
          match
            ? `Bob matched Eve's resend basis ${basisIcon(sourceBasis)}, so he reads Eve's bit.`
            : "Bob used a different basis than Eve's resend basis, so the result is random."
        );
      } else {
        setBubble("Measured",
          match
            ? "Bases match, so Bob gets the correct bit."
            : "Bases differ, so the result becomes random."
        );
      }

      const r = pipe.getBoundingClientRect();
      sparkle(r.width * 0.85, r.height * 0.62, match ? "‚úì" : "üé≤");

      updateUI();
    });

    btnRevealBases.addEventListener("click", () => {
      state.phase = "REVEALED";

      const match = (state.bobBasis === state.aliceBasis);
      if (match){
        state.kept += 1;
        state.aliceKey.push(String(state.aliceBit));
        state.bobKey.push(String(state.bobBit));
      }

      setBubble("Reveal bases",
        match
          ? "Bases match. Keep this bit for your secret key."
          : "Bases don‚Äôt match. Discard this round."
      );

      updateUI();
    });

    btnNextRound.addEventListener("click", () => {
      resetRound();
      setBubble("Next photon", "Pick a new bit and basis.");
    });

    btnResetRound.addEventListener("click", () => {
      resetRound();
      setBubble("Round reset", "Pick a bit and basis again.");
    });

    btnResetAll.addEventListener("click", resetAll);
    btnFinalizeGame.addEventListener("click", () => {
      if (state.aliceKey.length === 0 || state.bobKey.length === 0){
        setBubble("Finalize game", "Build some sifted key bits first, then finalize and compare keys.");
        return;
      }
      const sameLength = state.aliceKey.length === state.bobKey.length;
      const sameBits = sameLength && state.aliceKey.every((bit, i) => bit === state.bobKey[i]);
      showResultOverlay(sameBits);
      if (sameBits){
        setBubble("Victory", "Alice and Bob keys match. Secret key accepted.");
      } else {
        setBubble("Mismatch detected", "Alice and Bob keys differ. Key discarded due to possible Eve attack.");
      }
    });
    btnEveMode.addEventListener("click", () => {
      if (eveMode.active) return;
      eveMode.enabled = !eveMode.enabled;
      updateEveToggleButton();
      if (eveMode.enabled){
        setBubble("Eve mode enabled", "When you click Send, Eve will try to intercept in-channel.");
        if (!eveModeTutorialSeen && !tourActive){
          eveModeTutorialSeen = true;
          setTimeout(() => tutorialStart(eveModeTutorialSteps), 180);
        }
      } else {
        setBubble("Eve mode disabled", "Standard BB84 flow restored (no Eve interception challenge).");
      }
    });

    function wait(ms){ return new Promise(res => setTimeout(res, ms)); }
    resultCloseBtn.addEventListener("click", hideResultOverlay);
    resultResetBtn.addEventListener("click", () => {
      hideResultOverlay();
      resetAll();
    });

    /* =========================
       ‚úÖ Guided tutorial logic
       ========================= */
    const overlay = document.getElementById("tourOverlay");
    const tooltip = document.getElementById("tourTooltip");
    const welcomeOverlay = document.getElementById("welcomeOverlay");
    const welcomeStartBtn = document.getElementById("welcomeStartBtn");
    const tourTitleEl = document.getElementById("tourTitle");
    const tourBodyEl = document.getElementById("tourBody");
    const tourCounterEl = document.getElementById("tourCounter");
    const tourNextBtn = document.getElementById("tourNextBtn");
    const tourSkipBtn = document.getElementById("tourSkipBtn");

    let tourActive = false;
    let tourIndex = 0;
    let tourHighlightEl = null;
    let currentTourSteps = [];
    let eveModeTutorialSeen = false;

    const mainTourSteps = [
      {
        title: "Welcome!",
        body: "This quick tutorial will guide you through one full BB84 round. Click Next to begin.",
        target: "header",
        canProceed: () => true
      },
      {
        title: "Step 1 ‚Äî Choose a bit",
        body: "Pick a secret bit: 0 or 1.",
        target: "#bitChoices",
        canProceed: () => state.aliceBit !== null
      },
      {
        title: "Step 2 ‚Äî Choose a basis",
        body: "Now choose a basis (a ‚Äúlens‚Äù): ‚ûï or ‚úñ.",
        target: "#basisChoices",
        canProceed: () => state.aliceBasis !== null
      },
      {
        title: "Step 3 ‚Äî Encode",
        body: "Click ‚ÄúEncode Photon‚Äù to prepare the photon with your bit + basis.",
        target: "#btnEncode",
        canProceed: () => state.phase === "ENCODED"
      },
      {
        title: "Step 4 ‚Äî Send",
        body: "Send the photon through the quantum channel to Bob.",
        target: "#btnSend",
        canProceed: () => state.phase === "SENT"
      },
      {
        title: "Step 5 ‚Äî Bob measures",
        body: "Bob randomly chooses a basis and measures the photon.",
        target: "#btnMeasure",
        canProceed: () => state.phase === "MEASURED"
      },
      {
        title: "Step 6 ‚Äî Reveal bases",
        body: "Now you reveal bases (not bits). If bases match, you keep the bit!",
        target: "#btnRevealBases",
        canProceed: () => state.phase === "REVEALED"
      },
      {
        title: "Step 7 ‚Äî Next photon",
        body: "Start another round. Repeat to build a shared key.",
        target: "#btnNextRound",
        canProceed: () => state.phase === "PICK"
      },
      {
        title: "Optional ‚Äî Eve mode",
        body: "Turn on Eve Attack mode to simulate interception attacks during Send.",
        target: "#btnEveMode",
        canProceed: () => true
      },
      {
        title: "All set!",
        body: "You finished the guided round. Have fun experimenting!",
        target: ".board",
        canProceed: () => true,
        finish: true
      }
    ];

    const eveModeTutorialSteps = [
      {
        title: "Eve Mode Enabled",
        body: "Great. Eve Attack mode is now ON.",
        target: "#btnEveMode",
        canProceed: () => true
      },
      {
        title: "When it runs",
        body: "After you Encode and click Send, the channel challenge starts.",
        target: "#btnSend",
        canProceed: () => true
      },
      {
        title: "How to control",
        body: "Use Arrow keys or WASD to guide the message to Bob's side.",
        target: "#pipe",
        canProceed: () => true
      },
      {
        title: "If Eve intercepts",
        body: "Eve measures, re-encodes with a random basis, and sends her photon to Bob.",
        target: "#pipe",
        canProceed: () => true
      },
      {
        title: "Why this matters",
        body: "Interceptions can create Alice/Bob key mismatches. Use Finalize Game to compare keys.",
        target: "#btnFinalizeGame",
        canProceed: () => true,
        finish: true
      }
    ];

    function tutorialStart(steps = mainTourSteps){
      currentTourSteps = steps;
      tourActive = true;
      tourIndex = 0;
      overlay.classList.add("show");
      tooltip.classList.add("show");
      showTourStep();
      window.addEventListener("resize", positionTooltip, { passive: true });
      window.addEventListener("scroll", positionTooltip, { passive: true });
    }

    function tutorialFinish(){
      tourActive = false;
      overlay.classList.remove("show");
      tooltip.classList.remove("show");
      clearHighlight();
      window.removeEventListener("resize", positionTooltip);
      window.removeEventListener("scroll", positionTooltip);
    }

    function clearHighlight(){
      if (tourHighlightEl){
        tourHighlightEl.classList.remove("tourHighlight");
        tourHighlightEl = null;
      }
    }

    function getTargetEl(step){
      const el = document.querySelector(step.target);
      return el || document.body;
    }

    function showTourStep(){
      const step = currentTourSteps[tourIndex];
      tourTitleEl.textContent = step.title;
      tourBodyEl.textContent = step.body;
      tourCounterEl.textContent = `${tourIndex + 1} / ${currentTourSteps.length}`;

      clearHighlight();
      const targetEl = getTargetEl(step);
      tourHighlightEl = targetEl;
      tourHighlightEl.classList.add("tourHighlight");

      // If target is inside a scrollable view, bring it into view nicely.
      try {
        targetEl.scrollIntoView({ behavior: "smooth", block: "center", inline: "nearest" });
      } catch {}

      positionTooltip();
      tutorialUpdate();
    }

    function positionTooltip(){
      if (!tourActive) return;
      const step = currentTourSteps[tourIndex];
      const targetEl = getTargetEl(step);
      const r = targetEl.getBoundingClientRect();

      // default place below target; if no room, place above.
      const pad = 12;
      const tipW = tooltip.offsetWidth || 360;
      const tipH = tooltip.offsetHeight || 160;

      let top = r.bottom + 10;
      if (top + tipH > window.innerHeight - pad){
        top = r.top - tipH - 10;
      }
      top = Math.max(pad, Math.min(top, window.innerHeight - tipH - pad));

      let left = r.left + (r.width / 2) - (tipW / 2);
      left = Math.max(pad, Math.min(left, window.innerWidth - tipW - pad));

      tooltip.style.top = `${top}px`;
      tooltip.style.left = `${left}px`;
    }

    function tutorialUpdate(){
      if (!tourActive) return;
      const step = currentTourSteps[tourIndex];
      const ok = !!step.canProceed?.();
      tourNextBtn.disabled = !ok;

      // If the step is "finish", label it nicer
      if (step.finish){
        tourNextBtn.textContent = "Done";
        tourNextBtn.disabled = false;
      } else {
        tourNextBtn.textContent = "Next";
      }
    }

    tourNextBtn.addEventListener("click", () => {
      if (!tourActive) return;
      const step = currentTourSteps[tourIndex];
      if (!step.finish && step.canProceed && !step.canProceed()) return;

      if (step.finish){
        tutorialFinish();
        return;
      }
      tourIndex = Math.min(tourIndex + 1, currentTourSteps.length - 1);
      showTourStep();
    });

    tourSkipBtn.addEventListener("click", () => {
      tutorialFinish();
    });

    // Start tutorial on each page load
    function maybeStartTutorial(){
      // Show tutorial after first render
      setTimeout(() => tutorialStart(), 250);
    }

    function showWelcome(){
      welcomeOverlay.classList.add("show");
    }

    function closeWelcomeAndStartTutorial(){
      welcomeOverlay.classList.remove("show");
      maybeStartTutorial();
    }

    welcomeStartBtn.addEventListener("click", closeWelcomeAndStartTutorial);

    /* =========================
       Init
       ========================= */
    resetRound();
    updateEveToggleButton();
    setBubble("Welcome", "Pick a bit (0/1) and a basis (‚ûï/‚úñ), then encode.");
    updateUI();
    showWelcome();
  </script>
</body>
</html>
